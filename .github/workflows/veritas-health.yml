name: Veritas Nexus • Health (Auto)

env:
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  DB_URL: ${{ secrets.DB_URL }}
  OPENSEARCH_URL: ${{ secrets.OPENSEARCH_URL }}
  MINIO_ENDPOINT: ${{ secrets.MINIO_ENDPOINT }}
  MINIO_ROOT_USER: ${{ secrets.MINIO_ROOT_USER }}
  MINIO_ROOT_PASSWORD: ${{ secrets.MINIO_ROOT_PASSWORD }}
  REDIS_URL: ${{ secrets.REDIS_URL }}
  NEO4J_URI: ${{ secrets.NEO4J_URI }}
  NEO4J_AUTH: ${{ secrets.NEO4J_AUTH }}
  CLICKHOUSE_URL: ${{ secrets.CLICKHOUSE_URL }}

on:
  push:
    branches: [ main, develop ]
  pull_request:
  schedule:
    - cron: "*/30 * * * *"   # تلقائي كل 30 دقيقة (UTC)
  # لا تشغيل يدوي هنا (لا workflow_dispatch)، كل شيء تلقائي

jobs:
  health-check:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      # استهداف محلي (docker-compose) بشكل افتراضي
      CORE_URL: http://localhost:8080
      OSINT_URL: http://localhost:8081
      NEO4J_HTTP: http://localhost:7474
      NEO4J_USER: ${{ secrets.NEO4J_USER }}
      NEO4J_PASS: ${{ secrets.NEO4J_PASS }}
      # لو عندك فحص عبر Services داخل K8s، وفّرت kubeconfig كسِر
      KUBECONFIG_B64: ${{ secrets.KUBECONFIG_B64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq netcat-openbsd curl

      - name: Auto-select K8s Services if kubeconfig is provided
        if: ${{ env.KUBECONFIG_B64 != '' }}
        run: |
          echo "$KUBECONFIG_B64" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          # استهدف Services داخل الكلاستر بدل localhost
          echo "CORE_URL=http://veritas-core-svc"      >> $GITHUB_ENV
          echo "OSINT_URL=http://osint-engine-svc:8081" >> $GITHUB_ENV
          echo "NEO4J_HTTP=http://neo4j:7474"           >> $GITHUB_ENV

      - name: Show targets
        run: |
          echo "CORE_URL=$CORE_URL"
          echo "OSINT_URL=$OSINT_URL"
          echo "NEO4J_HTTP=$NEO4J_HTTP"

      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip
          pip3 install -r requirements.txt

      - name: Start Core API service
        run: |
          echo "Starting Core API service on port 8000..."
          cd $GITHUB_WORKSPACE
          python3 -m uvicorn api_server:app --host 0.0.0.0 --port 8000 &
          API_PID=$!
          echo "API_PID=$API_PID" >> $GITHUB_ENV
          echo "Core API started with PID: $API_PID"

      - name: Start Veritas Web service 
        run: |
          echo "Starting Veritas Web service on port 8080..."
          cd $GITHUB_WORKSPACE/veritas-web
          pip3 install -r requirements.txt
          python3 app.py &
          WEB_PID=$!
          echo "WEB_PID=$WEB_PID" >> $GITHUB_ENV
          echo "Veritas Web started with PID: $WEB_PID"

      - name: Wait for services to be ready
        run: |
          echo "Waiting for services to start..."
          sleep 10
          
          # Wait for Core API with better error handling
          echo "Checking Core API readiness..."
          API_READY=false
          for i in {1..30}; do
            if curl -f --connect-timeout 5 --max-time 10 http://localhost:8000/health >/dev/null 2>&1; then
              echo "✅ Core API is ready"
              API_READY=true
              break
            fi
            echo "⏳ Waiting for Core API... ($i/30)"
            sleep 2
          done
          
          if [ "$API_READY" != "true" ]; then
            echo "❌ Core API failed to start within timeout"
            echo "Checking if process is still running..."
            if ps -p $API_PID > /dev/null 2>&1; then
              echo "Process is running but not responding"
            else
              echo "Process has died"
            fi
            exit 1
          fi
          
          # Wait for Veritas Web with better error handling
          echo "Checking Veritas Web readiness..."
          WEB_READY=false
          for i in {1..30}; do
            if curl -f --connect-timeout 5 --max-time 10 http://localhost:8080/health >/dev/null 2>&1; then
              echo "✅ Veritas Web is ready"
              WEB_READY=true
              break
            fi
            echo "⏳ Waiting for Veritas Web... ($i/30)"
            sleep 2
          done
          
          if [ "$WEB_READY" != "true" ]; then
            echo "❌ Veritas Web failed to start within timeout"
            echo "Checking if process is still running..."
            if ps -p $WEB_PID > /dev/null 2>&1; then
              echo "Process is running but not responding"
            else
              echo "Process has died"
            fi
            exit 1
          fi

      - name: Make script executable
        run: chmod +x scripts/veritas_health_check.sh

      - name: Run health checks (with retry)
        id: runcheck
        run: |
          set -o pipefail
          
          echo "=== Pre-health check debugging ==="
          echo "Processes on port 8000:"
          netstat -tulpn | grep :8000 || echo "No process on port 8000"
          echo "Processes on port 8080:"
          netstat -tulpn | grep :8080 || echo "No process on port 8080"
          echo "=== Running health checks ==="
          
          attempt() {
            echo "== Veritas Health Check Attempt $1 ($(date -u +%FT%TZ)) =="
            ./scripts/veritas_health_check.sh
          }
          # محاولتان تلقائيًا لتجاوز أي تعثر مؤقت
          attempt 1 2>&1 | tee health.log || (sleep 10 && attempt 2 2>&1 | tee -a health.log)

      - name: Cleanup services
        if: ${{ always() }}
        run: |
          echo "Cleaning up services..."
          if [ ! -z "$API_PID" ]; then
            echo "Stopping Core API (PID: $API_PID)"
            kill $API_PID 2>/dev/null || true
          fi
          if [ ! -z "$WEB_PID" ]; then
            echo "Stopping Veritas Web (PID: $WEB_PID)"
            kill $WEB_PID 2>/dev/null || true
          fi
          # Also kill any remaining processes on the ports
          pkill -f "uvicorn.*8000" 2>/dev/null || true
          pkill -f "python.*app.py" 2>/dev/null || true
          echo "Cleanup complete"

      - name: Upload health log
        if: ${{ success() || failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: veritas-health-log
          path: health.log
          retention-days: 7

      - name: Job summary
        if: ${{ success() || failure() }}
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "### ✅ Health Check: **PASSED**" >> $GITHUB_STEP_SUMMARY
            echo "- Core/OSINT/Neo4j جميعها تعمل." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ❌ Health Check: **FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "- راجع Artifact: **veritas-health-log**." >> $GITHUB_STEP_SUMMARY
          fi

      # فتح Issue تلقائي عند الفشل
      - name: Open Issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let tail = 'log unavailable';
            try {
              tail = fs.readFileSync('health.log','utf8').split('\n').slice(-120).join('\n');
            } catch(e) {}
            const title = `❌ Veritas Health Failed – ${new Date().toISOString()}`;
            const body = [
              'Health check failed.',
              `Run: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              `Commit: ${context.sha}`,
              '',
              '#### Tail of health.log',
              '```',
              tail,
              '```'
            ].join('\n');
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ['health-check','automation','bug']
            });

      # إغلاق أي Issues مفتوحة للصحة تلقائيًا عند النجاح
      - name: Auto-close health issues on success
        if: ${{ success() }}
        uses: actions/github-script@v7
        with:
          script: |
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'health-check'
            });
            for (const i of issues) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: i.number,
                body: `✅ Health restored in run https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: i.number,
                state: 'closed'
              });
            }
